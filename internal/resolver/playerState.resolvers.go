package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"

	werrors "github.com/cockroachdb/errors"
	"github.com/rustic-beans/spotify-viewer/internal/models"
	"github.com/rustic-beans/spotify-viewer/internal/utils"
	"go.uber.org/zap"
)

// PlayerState is the resolver for the playerState field.
func (r *queryResolver) PlayerState(ctx context.Context) (*models.PlayerState, error) {
	return r.SharedService.GetPlayerState(ctx)
}

// PlayerState is the resolver for the playerState field.
func (r *subscriptionResolver) PlayerState(ctx context.Context) (<-chan *models.PlayerState, error) {
	utils.Logger.Info("Adding PlayerState subscription")
	id, ch := r.PlayerStateWebsocketHandler.AddConnection()
	utils.Logger.Info("PlayerState subscription added", zap.String("id", id))

	go func(id string) {
		<-ctx.Done()
		r.PlayerStateWebsocketHandler.RemoveConnection(id)
		utils.Logger.Info("PlayerState subscription closed", zap.String("id", id))
	}(id)

	utils.Logger.Debug("Getting PlayerState for client", zap.String("id", id))
	playerState, err := r.SharedService.GetPlayerState(ctx)
	if err != nil {
		utils.Logger.Error("Failed getting player state", zap.Error(err))
		return nil, werrors.Wrap(err, "failed getting player state")
	}
	utils.Logger.Debug("Got PlayerState, broadcasting")
	ch <- playerState

	return ch, nil
}
